"""
colibri.mc_utils.py

Module containing utils functions for the Monte Carlo fit.

"""

import jax
import jax.numpy as jnp

import os
import numpy as np
import yaml
from dataclasses import dataclass, asdict

from colibri.training_validation import training_validation_split
from colibri.constants import LHAPDF_XGRID, evolution_to_flavour_matrix, EXPORT_LABELS

import logging

log = logging.getLogger(__name__)


@dataclass(frozen=True)
class MCPseudodata:
    pseudodata: jnp.array
    training_indices: jnp.array
    validation_indices: jnp.array
    trval_split: bool = False

    def to_dict(self):
        return asdict(self)


def mc_pseudodata(
    pseudodata_central_covmat_index,
    replica_index,
    trval_seed,
    shuffle_indices=True,
    mc_validation_fraction=0.2,
):
    """Produces Monte Carlo pseudodata for the replica with index replica_index.
    The pseudodata is returned with a set of training indices, which account for
    a fraction mc_validation_fraction of the data.
    """

    central_values = pseudodata_central_covmat_index.central_values
    covmat = pseudodata_central_covmat_index.covmat
    all_indices = pseudodata_central_covmat_index.central_values_idx

    # Generate pseudodata according to a multivariate Gaussian centred on
    # central_values and with covariance matrix covmat.
    key = jax.random.PRNGKey(replica_index)
    pseudodata = jax.random.multivariate_normal(
        key,
        central_values,
        covmat,
    )

    # Now select a subset of 1 - mc_validation_fraction indices to be the
    # training indices.
    if not mc_validation_fraction:
        return MCPseudodata(
            pseudodata=pseudodata,
            training_indices=all_indices,
            validation_indices=jnp.array([]),
            trval_split=False,
        )

    trval_obj = training_validation_split(
        all_indices,
        mc_validation_fraction,
        trval_seed,
        shuffle_indices,
    )

    training_indices = trval_obj.training
    validation_indices = trval_obj.validation

    return MCPseudodata(
        pseudodata=pseudodata,
        training_indices=training_indices,
        validation_indices=validation_indices,
        trval_split=True,
    )


def len_trval_data(mc_pseudodata):
    """Returns the number of training data points."""
    return len(mc_pseudodata.training_indices), len(mc_pseudodata.validation_indices)


def write_exportgrid(
    parameters,
    pdf_model,
    replica_index,
    output_path,
    monte_carlo=False,
):
    """
    Writes an exportgrid for each of the replicas in the posterior sample.
    The exportgrids are written to a folder called "replicas" in the output_path.
    The exportgrids are written in the format required by EKO, but are not yet
    evolved.

    Parameters
    ----------
    parameters: list
        The list of parameters defining the replica in the model parametrisation.

    pdf_model: PDFModel
        The PDF model which relates the parameters to the PDF grid values.

    replica_index: int
        The replica number which will be written.

    output_path: pathlib.PosixPath
        Path to the output folder.

    monte_carlo: bool
        Whether the fit is a Monte Carlo fit. If True, the exportgrids are written
        to a folder called "fit_replicas" in the output_path.
    """

    # In a Monte Carlo fit a postfit selection is performed on the replicas
    # in fit_replicas. The replicas folder is generated by the postfit script.
    if monte_carlo:
        replicas_path = str(output_path) + "/fit_replicas"
    else:
        replicas_path = str(output_path) + "/replicas"

    rep_path = replicas_path + f"/replica_{replica_index}"
    if not os.path.exists(rep_path):
        os.mkdir(rep_path)

    fit_name = str(output_path).split("/")[-1]

    # Create the exportgrid
    lhapdf_interpolator = pdf_model.grid_values_func(LHAPDF_XGRID)

    # Rotate the grid from the evolution basis into the export grid basis
    grid_for_writing = np.array(lhapdf_interpolator(parameters))
    grid_for_writing = evolution_to_flavour_matrix @ grid_for_writing
    grid_for_writing = grid_for_writing.T.tolist()

    # Prepare a dictionary for the exportgrid
    export_grid = {}

    # Set the initial Q2 value, which will always be the same.
    export_grid["q20"] = (1.65) ** 2
    export_grid["xgrid"] = LHAPDF_XGRID
    export_grid["replica"] = int(replica_index)
    export_grid["labels"] = EXPORT_LABELS

    export_grid["pdfgrid"] = grid_for_writing

    with open(rep_path + "/" + fit_name + ".exportgrid", "w") as outfile:
        yaml.dump(export_grid, outfile)
